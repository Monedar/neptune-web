import { RenderTabs, LiveEditorBlock, GeneratePropsTable } from '../../utils';
import { Button, InstructionsList} from '@transferwise/components';
import code from '../../liveEditorCode/button.code';
const dos = [
  'Use buttons to start, save, discard or conclude a transaction flow',
  'Use sentence case in the button labels',
  'Write the button label so that it describes the action as clearly but also as succinctly as possible. Use a verb that allows the user to understand what happens when she presses the button. E.g "Add a balance" or "Send money".',
  'Use button groups to organize related functions',
  'Use only one [Primary](#primary) or [Pay](#pay) button per view or functional area',
  'Pair Primary or Pay buttons with [Secondary](#secondary) ones',
  'Primary or Pay button is always the first in the group',
];
const donts = [
  'Use buttons to link pages which are not part of your transaction flow',
  'Use butons to link purely content pages',
  'Use buttons link external websites',
  'Pair Pay and Primary buttons unless extremely necessary',
  'Group buttons of different sizes',
  'Group circular and rectangular buttons',
];

Use buttons to let users take actions like starting a transfer or saving the progress and move to
the next step.

<RenderTabs>
#web
<>
  <LiveEditorBlock code={code} scope={{ Button }} />
  <GeneratePropsTable componentName="Button" />
</>
#ios
</RenderTabs>

## Best practices

<InstructionsList dos={dos} donts={donts} />

## Button types

<table className="table table-condensed">
  <thead>
    <tr>
      <th>Type</th>
      <th>Large</th>
      <th>Small</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">Primary</th>
      <td>
        Main call to action. Try to limit it to one per view. 
      </td>
      <td>
       <Button size="md" type="primary" state="default" block={false} onClick={() => null}>Add balance</Button> 
      </td>
    </tr><tr>
      <th scope="row">Pay</th>
      <td>
        Reserved to initiate or confirm a money transaction. Limit to one per view. 
      </td>
      <td>
       <Button size="md" type="pay" state="default" block={false} onClick={() => null}>Send money</Button> 
      </td>
    </tr>
    <tr>
      <th scope="row">Secondary</th>
      <td>
        Secondary actions or less important actions. Consider it the default when adding a new button.   
      </td>
      <td>
       <Button size="md" type="secondary" state="default" block={false} onClick={() => null}>Manage my card</Button>
      </td>
    </tr> <tr>
      <th scope="row">Danger</th>
      <td>
        Actions that may result in loose of data and effort from the user and cannot be recovered. E.g Delete.   
      </td>
      <td>
       <Button size="md" type="danger" state="default" block={false} onClick={() => null}>Delete recipient</Button> 
      </td>
    </tr>
    
  </tbody>
</table>



#### Dropdown <span className="badge badge-success">Web</span>

It opens a dropdown menu with several options related to the button action. Use it when there's limited horizontal space and the user can anticipate the options in the menu. E.g Share with Facebook, Twitter, Whatsapp etc.

#### Split <span className="badge badge-success">Web</span>

It offers a direct main action and a dropwdown menu including more than two secondary actions. Use it when there's limited horizontal space. To certain extent, the user should be able to anticipate some of the secondary actions in the menu. E.g Primary action: Edit. Secondary actions: Delete, Copy, etc..

#### Circular <span className="badge badge-success">Apps</span>

Use circular buttons when you have a group of related actions and limited horizontal space.

export const meta = {
  abstractURL: 'https://share.goabstract.com/fa817bb3-ef94-4317-8a8d-864a89df7de0',
  name: 'Button',
  size: '',
};
